<DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmo</title>
    <style>
        video {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
<body bgcolor="cyan">
 <h1> Algoritmo  </h1>
<p> Un algoritmo es una secuencia finita y ordenada de instrucciones o pasos que se siguen para resolver un problema o realizar una tarea espec√≠fica. Estos pasos deben ser bien definidos y ejecutables para producir un resultado, sirviendo como la base de la programaci√≥n y el desarrollo de software. </p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/LampFlowchart-es.svg/1200px-LampFlowchart-es.svg.png"  width="500" height="600"> 
<img src="https://concepto.de/wp-content/uploads/2018/04/algoritmo-min-e1523301106897.jpg"  width="550" height="400"> 
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqHwUGEftbslnEMbKfZ8s7CyTkNUq7Ij1qHw&s"  width="550" height="400"> 
<h2> Caracter√≠sticas clave de los algoritmos </h2>
<ol> - Finito: Los algoritmos deben tener un n√∫mero limitado de pasos para completarse. </ol>
<ol> - Ordenado: Los pasos deben seguir un orden espec√≠fico para garantizar la resoluci√≥n del problema. </ol>
<ol> - Definido: Cada paso debe estar claramente definido y sin ambig√ºedades. </ol>
<ol> - Ejecutable: Los pasos deben poder ser llevados a cabo por un sistema o m√°quina. </ol> 
<ol> - Resultante: Los algoritmos deben producir un resultado espec√≠fico al finalizar. </ol>
<h2> Ejemplos de algoritmos </h2>
<ol> - Receta de cocina: </ol>
<p> Una receta es un algoritmo que detalla los pasos para preparar una comida. </p>
<ol> - Instrucciones de montaje: </ol>
<p> Las instrucciones para armar un mueble son un algoritmo que gu√≠a el proceso de ensamblaje. </p>
<ol> - Algoritmos de ordenamiento: </ol>
<p> En inform√°tica, los algoritmos de ordenamiento (como el de burbuja o el de selecci√≥n) organizan listas de elementos en un orden espec√≠fico. </p>
<ol> - Algoritmos de b√∫squeda: </ol>
<p> Los motores de b√∫squeda utilizan algoritmos para encontrar informaci√≥n relevante a partir de una consulta. </p>
<ol> - Algoritmos de recomendaci√≥n: </ol>
<p> Platarformas como Netflix o Spotify utilizan algoritmos para recomendar contenido a los usuarios. 
En matem√°ticas, l√≥gica, ciencias de la computaci√≥n y disciplinas relacionadas, un algoritmo es un conjunto de instrucciones o reglas definidas y no-ambiguas, ordenadas y finitas que permite, t√≠picamente, solucionar un problema, realizar un c√≥mputo, procesar datos y llevar a cabo otras tareas o actividades.‚Äã Tambi√©n sirve para resolver un cubo de Rubik. Dado un estado inicial y una entrada, siguiendo los pasos sucesivos se llega a un estado final y se obtiene una soluci√≥n. Los algoritmos son el objeto de estudio de la algoritmia.</p>
<h2> Etimolog√≠a </h2>
<p> La palabra castellana algoritmo deriva del lat√≠n algorithmus, que se acu√±ar√≠a en el siglo XV a partir del lat√≠n algorismus, con influencia del griego arithmos, que significa ¬´n√∫mero¬ª, o de la latinizaci√≥n del apellido del matem√°tico persa Al-Juarismi.[2]‚Äã[6]‚ÄãLa RAE, por su parte, propone que deriva del lat√≠n algobarismus, que derivar√≠a del √°rabe cl√°sico ·∏•isƒÅbu l·∏°ubƒÅr, que significa ¬´c√°lculo mediante cifras ar√°bigas¬ª.</p>
<img src="https://elingenieroenaccion.files.wordpress.com/2018/09/que-es-un-algoritmo-featured.png"  width="600" height="600">  
<h2> Medios de expresi√≥n de un algoritmo </h2>
<p> Los algoritmos pueden ser expresados de muchas maneras, incluyendo al lenguaje natural, pseudoc√≥digo, diagramas de flujo y lenguajes de programaci√≥n entre otros. Las descripciones en lenguaje natural tienden a ser ambiguas y extensas. El usar pseudoc√≥digo y diagramas de flujo evita muchas ambig√ºedades del lenguaje natural. Dichas expresiones son formas m√°s estructuradas para representar algoritmos; no obstante, se mantienen independientes de un lenguaje de programaci√≥n espec√≠fico.</p>
<p> La descripci√≥n de un algoritmo suele hacerse en tres niveles:</p>
<ol> - Descripci√≥n de alto nivel. Se establece el problema, se selecciona un modelo matem√°tico y se explica el algoritmo de manera verbal, posiblemente con ilustraciones y omitiendo detalles. </ol>
<ol> - Descripci√≥n formal. Se usa un pseudoc√≥digo para describir la secuencia de pasos que encuentran la soluci√≥n. </ol>
<ol> - Implementaci√≥n. Se muestra el algoritmo expresado en un lenguaje de programaci√≥n espec√≠fico o alg√∫n objeto capaz de llevar a cabo instrucciones. </ol>
<p>Tambi√©n es posible incluir un teorema que demuestre que el algoritmo es correcto, un an√°lisis de complejidad o ambos.</p>
<img src="data:image/jpeg;base64,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 "  width="500" height="400">  
<h2> Diagrama de flujo </h2>
<p> Los diagramas de flujo son descripciones gr√°ficas de algoritmos; usan s√≠mbolos conectados con flechas para indicar la secuencia de instrucciones y est√°n regidos por ISO.</p>
<p> Los diagramas de flujo se emplean para representar algoritmos peque√±os, ya que abarcan mucho espacio y su construcci√≥n es laboriosa. Por su facilidad de lectura se utilizan como introducci√≥n a los algoritmos, descripci√≥n de un lenguaje y descripci√≥n de procesos a personas ajenas a la computaci√≥n.</p>
<h2> Pseudoc√≥digo </h2>
<p> El pseudoc√≥digo (falso lenguaje, el prefijo pseudo significa falso) es una descripci√≥n de alto nivel de un algoritmo que emplea una mezcla de lenguaje natural con algunas convenciones sint√°cticas propias de lenguajes de programaci√≥n, como asignaciones, ciclos y condicionales, aunque no est√° regido por ning√∫n est√°ndar.</p>
<p> El pseudoc√≥digo est√° pensado para facilitar a las personas el entendimiento de un algoritmo y, por lo tanto, puede omitir detalles irrelevantes que son necesarios en una implementaci√≥n. Programadores diferentes suelen utilizar convenciones distintas, que pueden estar basadas en la sintaxis de lenguajes de programaci√≥n concretos. Sin embargo, el pseudoc√≥digo, en general, es comprensible sin necesidad de conocer o usar un entorno de programaci√≥n espec√≠fico, y es a la vez suficientemente estructurado para que su implementaci√≥n se pueda hacer directamente a partir de √©l.</p>
<p> As√≠, el pseudoc√≥digo cumple con las funciones antes mencionadas para representar algo abstracto, los protocolos son los lenguajes para la programaci√≥n. Busque fuentes m√°s precisas para tener mayor comprensi√≥n del tema.</p>
<h2> Sistemas formales </h2> 
<p> La teor√≠a de aut√≥matas y la teor√≠a de funciones recursivas proveen modelos matem√°ticos que formalizan el concepto de algoritmo. Los modelos m√°s comunes son la m√°quina de Turing, m√°quina de registro y funciones Œº-recursivas. Estos modelos son tan precisos como un lenguaje m√°quina, careciendo de expresiones coloquiales o ambig√ºedad; sin embargo, se mantienen independientes de cualquier computadora y de cualquier implementaci√≥n.</p> 
<h2> Implementaci√≥n </h2>
<p> Muchos algoritmos se han ideado para implementarse en un programa. No obstante, los algoritmos pueden ser implementados en otros medios, como una red neuronal, un circuito el√©ctrico o un aparato mec√°nico y el√©ctrico. Algunos algoritmos incluso se dise√±an especialmente para implementarse usando l√°piz y papel. El algoritmo de multiplicaci√≥n tradicional, el algoritmo de Euclides, la criba de Erat√≥stenes y muchas formas de resolver la ra√≠z cuadrada son solo algunos ejemplos.</p>
<h2> Variables </h2>
<p> Son elementos que toman valores espec√≠ficos de un tipo de datos concreto. La declaraci√≥n de una variable puede realizarse comenzando con var. Principalmente, existen dos maneras de otorgar valores iniciales a variables:
Mediante una sentencia de asignaci√≥n.</p>
<p> Mediante un procedimiento de entrada de datos (por ejemplo: 'read').</p>
<h3> Ejemplo: </h3>
<p> ...</p> 
<p> i:=1; </p>
<p> read(n); </p> 
<p> while i < n do begin </p>
<p> (* cuerpo del bucle *) </p>
<p> i := i + 1 </p>
<p> end; </p>
<p> ... </p>
<h2> Estructuras secuenciales </h2>
<p> La estructura secuencial es aquella en la que una acci√≥n sigue a otra en secuencia. Las operaciones se suceden de tal modo que la salida de una es la entrada de la siguiente y as√≠ sucesivamente hasta el fin del proceso. La asignaci√≥n de esto consiste en el paso de valores o resultados a una zona de la memoria. Dicha zona ser√° reconocida con el nombre de la variable que recibe el valor. La asignaci√≥n se puede clasificar de la siguiente forma:</p>

<ol> Simples: Consiste en pasar un valor constante a una variable (a ‚Üê 15)</ol>
<ol> Contador: Consiste en usarla como un verificador del n√∫mero de veces que se realiza un proceso (a ‚Üê a + 1) </ol>
<ol> Acumulador: Consiste en usarla como un sumador en un proceso (a ‚Üê a + b) </ol>
<p> De trabajo: Donde puede recibir el resultado de una operaci√≥n matem√°tica que involucre muchas variables (a ‚Üê c + b*1/2).
<p> Un ejemplo de estructura secuencial, como obtener el √°rea de un tri√°ngulo:</p>
<p> Inicio </p>
<p> ... </p>
<p> float b, h, a; </p>
<p> printf("Diga la base"); </p>
<p> scanf("%f", &b);</p>
<p> printf("Diga la altura");</p>
<p> scanf("%f", &h);</p>
<p> a = (b*h)/2;</p>
<p> printf("El √°rea del tri√°ngulo es %f", a)</p>
<p> ... </p>
<p> Fin </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y19JABXAtTA?si=Ew5vOgoexRIIL3mE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/AlgoritmoRaiz.png/220px-AlgoritmoRaiz.png"  width="600" height="600"> 
<h2> Historia de los algoritmos </h2>
<h3> 1. Los Primeros Algoritmos (Antig√ºedad) </h3>
<p> Aunque el t√©rmino "algoritmo" como lo entendemos hoy no exist√≠a, las primeras civilizaciones ya utilizaban procedimientos sistem√°ticos para resolver problemas matem√°ticos.</p>
<h4> 3000 a.C. - Egipto y Babilonia</h4>
<p> Egipcios y babilonios utilizaban m√©todos de c√°lculo para resolver problemas pr√°cticos, como medir tierras o resolver ecuaciones simples, aunque estos procedimientos no eran formalmente algoritmos en el sentido moderno. Sin embargo, ya empleaban reglas secuenciales para realizar operaciones.</p>
<h4> 300 a.C. - Euclides y el algoritmo de Euclides</h4>
<p> Uno de los primeros algoritmos registrados es el algoritmo de Euclides para encontrar el m√°ximo com√∫n divisor (MCD) de dos n√∫meros. Este algoritmo, descrito por Euclides en su obra Elementos, sigue siendo uno de los m√°s importantes y se utiliza hasta el d√≠a de hoy.<p>

<h3> 2. Edad Media y el Renacimiento (Siglos V - XVI) </h3>
<p> Durante la Edad Media, los matem√°ticos isl√°micos y europeos continuaron desarrollando y transmitiendo t√©cnicas que pueden considerarse algoritmos en el sentido m√°s amplio.</p>
<h4> 800 d.C. - Al-Juarismi y la palabra "Algoritmo"</h4>
<p> El t√©rmino "algoritmo" proviene de Al-Juarismi, un matem√°tico y astr√≥nomo persa. Su obra Al-Kitab al-Mukhtasar fi Hisab al-Jabr wal-Muqabala (El libro sobre c√°lculo por restauraci√≥n y reducci√≥n) fue fundamental en la creaci√≥n del √°lgebra. En este libro, describi√≥ procedimientos sistem√°ticos para resolver ecuaciones lineales y cuadr√°ticas. Los procedimientos descritos por Al-Juarismi fueron una de las primeras formas de lo que m√°s tarde ser√≠a conocido como un algoritmo.<p>
<h4> Siglo XIII - Fibonacci</h4>
<p> Leonardo de Pisa (conocido como Fibonacci) introdujo en Europa el sistema num√©rico indo-ar√°bigo, que reemplaz√≥ al sistema romano y facilit√≥ los c√°lculos. Su obra Liber Abaci tambi√©n presentaba algoritmos para operaciones aritm√©ticas usando los nuevos n√∫meros.<p>

<h3> 3. El Siglo XVII y XVIII - El Nacimiento de la Ciencia de la Computaci√≥n </h3>
<p> Con el advenimiento de la Era Moderna, los conceptos de matem√°tica y algoritmos empezaron a formalizarse m√°s claramente.</p>
<h4>1620 - John Napier y los logaritmos</h4>
<p> John Napier desarroll√≥ los logaritmos, que simplificaron la multiplicaci√≥n y divisi√≥n de n√∫meros grandes. Aunque no era un "algoritmo" en el sentido de programaci√≥n, el concepto de reducir un problema complejo a pasos m√°s simples a trav√©s de tablas y reglas fue una contribuci√≥n importante al desarrollo del pensamiento algor√≠tmico.<p>
<h4> 1670 - Gottfried Wilhelm Leibniz y la m√°quina de calcular</h4>
<p>Leibniz ide√≥ un mecanismo para la multiplicaci√≥n utilizando la m√°quina de calcular. Este trabajo represent√≥ un avance importante hacia la creaci√≥n de m√°quinas autom√°ticas que ejecutaban secuencias de operaciones, precursoras de los algoritmos computacionales.</p>

<h3> 4. El Siglo XIX - El Desarrollo de la Computaci√≥n Te√≥rica </h3>
<h4> 1830 - Charles Babbage y la m√°quina anal√≠tica</h4>
Charles Babbage, considerado el padre de la computadora, dise√±√≥ la m√°quina anal√≠tica, que conten√≠a los elementos fundamentales de las computadoras modernas: una unidad de procesamiento, memoria y entrada/salida. Su m√°quina pod√≠a ejecutar algoritmos de manera secuencial para resolver problemas matem√°ticos complejos. Aunque nunca se construy√≥ una m√°quina funcional en su tiempo, sus ideas fueron fundamentales para el desarrollo de la computaci√≥n.
<h4> 1840 - Ada Lovelace y el primer algoritmo </h4>
<p> Ada Lovelace, la hija de Lord Byron, fue la primera persona en entender que la m√°quina anal√≠tica de Babbage pod√≠a ir m√°s all√° de simples c√°lculos num√©ricos. En sus notas, Lovelace escribi√≥ el primer algoritmo pensado para ser ejecutado por una m√°quina, espec√≠ficamente para calcular los n√∫meros de Bernoulli. Esta contribuci√≥n se considera el primer algoritmo inform√°tico y la base de la programaci√≥n moderna.<p>

<h3> 5. El Siglo XX - Formalizaci√≥n y Avances en Computaci√≥n </h3>
<h4> 1936 - Alan Turing y la m√°quina de Turing </h4>
<p> Alan Turing, en su trabajo sobre la m√°quina de Turing, formaliz√≥ la idea de un algoritmo como un conjunto de instrucciones que pueden ser ejecutadas paso a paso. La m√°quina de Turing se convirti√≥ en un modelo matem√°tico para la computaci√≥n y permiti√≥ definir el concepto de computaci√≥n y algoritmo en t√©rminos formales. La tesis de Church-Turing afirma que cualquier funci√≥n que pueda ser computada por un algoritmo puede ser calculada por una m√°quina de Turing.</p>
<h4> 1940 - Desarrollo de las primeras computadoras electr√≥nicas </h4>
<p> Con la creaci√≥n de las primeras computadoras electr√≥nicas, los algoritmos empezaron a ejecutarse en m√°quinas reales, dando lugar a la computaci√≥n moderna. Las primeras computadoras programables, como la ENIAC y la Colossus, empezaron a utilizar algoritmos para realizar tareas matem√°ticas complejas.</p>
<h4> 1950 - El avance en la programaci√≥n estructurada </h4>
<p> Los algoritmos comenzaron a ser implementados en lenguajes de programaci√≥n como Fortran, COBOL y LISP. Estos lenguajes permitieron la formalizaci√≥n de algoritmos complejos y la creaci√≥n de programas m√°s eficientes.</p>

<h3> 6. Finales del Siglo XX y el Siglo XXI - Algoritmos en la Era Digital </h3>
<h4> 1990 - El auge de la inform√°tica y el desarrollo de internet</h4>
La aparici√≥n de internet y las redes sociales ampli√≥ enormemente el uso de algoritmos en √°reas como la b√∫squeda de informaci√≥n (con el algoritmo de Google Search), la seguridad (con algoritmos de encriptaci√≥n), y el an√°lisis de datos (con big data y machine learning).
<h4> 2000 - Los algoritmos en la vida cotidiana</h4>
<p> En el siglo XXI, los algoritmos est√°n presentes en pr√°cticamente todos los aspectos de la vida diaria, desde recomendaciones de productos y servicios de streaming, hasta toma de decisiones financieras y veh√≠culos aut√≥nomos. </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/EkObhToiseo?si=76jOM6TuOirNu7pe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdN0YK3nFrxxk8YH85Gi9ZuxIi4h4o8ZakqQ&s"  width="600" height="600"> 
<img src="https://www.lifeder.com/wp-content/uploads/2017/12/algoritmo-concepto-lifeder.jpg"  width="600" height="600"> 
<h2> Tipos de Algoritmos </h2>
<table border="1">
<tr> 
<td>
‚Äã‚Äã<h2> 1. Algoritmos de B√∫squeda </h2>
<p> Los algoritmos de b√∫squeda se utilizan para encontrar un valor o una informaci√≥n dentro de una estructura de datos.</p>
<h3> Tipos comunes:</h3>
<ol> - B√∫squeda Lineal: Examina cada elemento en una lista secuencialmente hasta encontrar el valor deseado.</ol>
<ol> - B√∫squeda Binaria: Utilizada en listas ordenadas, divide el rango de b√∫squeda a la mitad en cada iteraci√≥n hasta encontrar el elemento.</ol>
<h3> Ejemplo: </h3>
<p> B√∫squeda Binaria en un arreglo ordenado de n√∫meros.</p>
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSZqq_Kr7fYByASOUCcAOIwU0kmnQzA6bQGow&s"  width="500" height="250"> 
</td>
<td>
<h2> 2. Algoritmos de Ordenaci√≥n </h2>
<p> Los algoritmos de ordenaci√≥n organizan un conjunto de datos en un orden espec√≠fico (ascendente o descendente).</p>
<h3> Tipos comunes:</h3>
<ol> - Ordenaci√≥n por Burbuja (Bubble Sort): Compara elementos adyacentes y los intercambia si est√°n en el orden incorrecto.</ol>
<ol> - Ordenaci√≥n R√°pida (Quick Sort): Utiliza un pivote para dividir y conquistar, ordenando los elementos en sublistas.</ol> 
<ol> - Ordenaci√≥n por Inserci√≥n (Insertion Sort): Inserta cada nuevo elemento en la posici√≥n correcta dentro de una lista ordenada. </ol>
<ol> - Merge Sort: Divide la lista en sublistas, las ordena y luego las fusiona.</ol>
<h3> Ejemplo: </h3>
<p> Ordenaci√≥n por Burbuja para ordenar una lista de n√∫meros.</p>
<img src="https://users.dcc.uchile.cl/~lmateu/CC10A/Apuntes/ordenamiento/seleccion.gif"  width="500" height="250"> 
</td>
<td>
<h2> 3. Algoritmos de Optimizaci√≥n</h2>
<p> Estos algoritmos se utilizan para encontrar la mejor soluci√≥n o el valor m√°s √≥ptimo bajo ciertas condiciones o restricciones.</p>
<h3> Tipos comunes:</h3>
<ol> - Algoritmo de Dijkstra: Encuentra el camino m√°s corto entre dos nodos en un grafo ponderado.</ol>
<ol> - Algoritmo A*: Utiliza heur√≠sticas para encontrar el camino m√°s corto entre puntos en un mapa o grafo.</ol>
<ol> - Algoritmo de Monte Carlo: Utiliza simulaci√≥n estoc√°stica para encontrar una soluci√≥n aproximada a problemas complejos.</ol>
<h3> Ejemplo: </h3>
<p> Dijkstra para encontrar el camino m√°s corto en un mapa de ciudades.</p>
<img src="https://cdn.agenciasinc.es/var/ezwebin_site/storage/images/noticias/un-algoritmo-probabilistico-para-optimizar-soluciones-complejas/8158941-2-esl-MX/Un-algoritmo-probabilistico-para-optimizar-soluciones-complejas.jpg"  width="500" height="250"> 
</td>
</tr>
<tr>
<td>
<h2> 4. Algoritmos de Divide y Vencer√°s</h2>
<p> Este tipo de algoritmo resuelve un problema dividi√©ndolo en subproblemas m√°s peque√±os, los resuelve de manera recursiva y luego combina las soluciones.</p>
<h3> Tipos comunes:</h3>
<ol> - Merge Sort: Divide el arreglo en sublistas, las ordena y luego las fusiona.</ol>
<ol> - Quick Sort: Divide el arreglo en dos partes con un pivote y ordena las partes recursivamente.</ol>
<h3> Ejemplo:</h3>
<p>  Merge Sort para ordenar una lista.</p>
<img src="https://cdn.kastatic.org/ka-perseus-images/db9d172fc33b90e905c1213b8cce660c228bb99c.png"  width="500" height="450"> 
</td>
<td>
<h2> 5. Algoritmos Voraces (Greedy)</h2>
<p> Son aquellos que, en cada paso, seleccionan la opci√≥n que parece ser la mejor en el momento, sin considerar las futuras consecuencias.</p>
<h3> Tipos comunes:</h3>
<ol> Algoritmo de Kruskal: Encuentra el √°rbol de expansi√≥n m√≠nima en un grafo.</ol>
<ol> Algoritmo de Prim: Tambi√©n encuentra el √°rbol de expansi√≥n m√≠nima en un grafo, pero con una estrategia diferente.</ol>
<h3> Ejemplo: </h3>
<p> Algoritmo de Kruskal para encontrar el √°rbol de expansi√≥n m√≠nima.</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/d/da/Greedy_algorithm_36_cents.svg"  width="300" height="150"> 
</td>
<td>
<h2> 6. Algoritmos de Programaci√≥n Din√°mica</h2>
<p> Estos algoritmos resuelven problemas complejos dividi√©ndolos en subproblemas m√°s peque√±os y luego combinando sus soluciones. Son muy √∫tiles cuando el mismo subproblema se repite muchas veces.</p>
<h3> Tipos comunes:</h3>
<p> Algoritmo de Fibonacci: Calcula el n-√©simo n√∫mero de Fibonacci utilizando programaci√≥n din√°mica. </p>
<p> Algoritmo de la mochila (Knapsack Problem): Resuelve problemas de optimizaci√≥n donde se deben seleccionar elementos con un valor y peso determinado.</p>
<p> Problema de la subsecuencia com√∫n m√°s larga: Encuentra la subsecuencia m√°s larga que es com√∫n en dos secuencias dadas. </p>
<h3> Ejemplo:</h3>
<p> Problema de la mochila donde se busca la combinaci√≥n m√°s valiosa de elementos sin exceder el peso m√°ximo. </p>
<img src="https://camo.githubusercontent.com/86c45fec5468cd06862e7b91b7d45722b6090259b3b44baebe2c66659d0827ad/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6d616b6569747265616c2f696d616765732f66756c6c2d737461636b2d637572726963756c756d2f64796e616d69632d70726f6772616d6d696e672d312e706e67"  width="400" height="250"> 
</td>
</tr>
<tr>
<td>
<h2> 7. Algoritmos de Recursi√≥n</h2>
<p> En estos algoritmos, la soluci√≥n de un problema depende de la soluci√≥n de subproblemas m√°s peque√±os del mismo tipo.</p>
<h3> Ejemplos comunes: </h3>
<ol> - Factorial de un n√∫mero: El factorial de un n√∫mero </ol>
<p> ùëõ </p>
<p> n se define como </p>
<p> ùëõ! = ùëõ √ó (ùëõ ‚àí 1) √ó ( ùëõ ‚àí 2 ) √ó ‚ãØ √ó 1</p>
<p> n!=n√ó(n‚àí1)√ó(n‚àí2)√ó‚ãØ√ó1.</p>
<ol> - Algoritmo de Fibonacci: La secuencia de Fibonacci puede calcularse recursivamente.</ol>
<h3> Ejemplo:</h3>
<p> Recursi√≥n para calcular el factorial de un n√∫mero.</p>
<img src="https://www.netmentor.es/imagen/f1c3ac2d-c77c-48d3-b5c1-227704aa9ff7.jpg"  width="400" height="250"> 
</td>
<td>
<h2> 8. Algoritmos de Grafos</h2>
<p> Se utilizan para resolver problemas relacionados con redes de nodos y enlaces. Los grafos pueden ser dirigidos o no dirigidos, y los algoritmos resuelven problemas como la b√∫squeda de caminos, conectividad, y el flujo m√°ximo.</p>
<h3> Tipos comunes:</h3>
<ol> - B√∫squeda en Profundidad (DFS): Explora un grafo comenzando desde un nodo y profundizando lo m√°s posible antes de retroceder.</ol>
<ol> - B√∫squeda en Anchura (BFS): Explora un grafo comenzando desde un nodo y recorriendo todos los nodos vecinos antes de profundizar m√°s.</ol>
<ol> - Algoritmo de Floyd-Warshall: Encuentra el camino m√°s corto entre todos los pares de nodos en un grafo.</ol>
<h3> Ejemplo:</h3>
<p> DFS para recorrer un laberinto.</p>
<img src="https://users.dcc.uchile.cl/~bebustos/apuntes/cc3001/Grafos/grafo1.gif"  width="500" height="250"> 
</td>
<td>
<h2> 9. Algoritmos de Encriptaci√≥n y Seguridad </h2>
<p> Estos algoritmos se utilizan para proteger la informaci√≥n a trav√©s de m√©todos de encriptaci√≥n y seguridad de datos.</p>
<h3> Tipos comunes:</h3>
<ol> - Algoritmo de Cifrado RSA: Utilizado para encriptar y proteger la informaci√≥n en sistemas de comunicaci√≥n.</ol>
<ol> - Algoritmo AES (Advanced Encryption Standard): Est√°ndar de encriptaci√≥n para proteger datos confidenciales.</ol>
<h3> Ejemplo: </h3>
<p> RSA para encriptar informaci√≥n confidencial.</p>
<img src="https://kinsta.com/wp-content/uploads/2023/07/what-is-encryption.jpg"  width="500" height="250"> 
</td>
</tr>
<tr>
<td>
<h2> 10. Algoritmos de Machine Learning (Aprendizaje Autom√°tico)</h2>
<p> Estos algoritmos permiten a las m√°quinas aprender patrones a partir de los datos y hacer predicciones o clasificaciones sin programaci√≥n expl√≠cita.</p>
<h3> Tipos comunes:</h3>
<ol> - Regresi√≥n Lineal: Utilizado para predecir un valor continuo basado en caracter√≠sticas de entrada.</ol>
<ol> - √Årboles de Decisi√≥n: Utilizados para clasificaci√≥n y regresi√≥n, dividen el conjunto de datos en grupos seg√∫n criterios espec√≠ficos. </ol>
<ol> - Redes Neuronales Artificiales: Modelos que imitan el cerebro humano y son utilizados para tareas como clasificaci√≥n de im√°genes, procesamiento de lenguaje natural, etc.</ol>
<h3> Ejemplo: </h3>
<p> √Årbol de decisi√≥n para clasificar correos electr√≥nicos como spam o no spam.</p>
<img src="https://vissonar.com/wp-content/uploads/2018/11/machine-learning-ejemplos-sector-fintech.jpg"  width="500" height="350"> 
</td>
<td>
<h2> 11. Algoritmos Evolutivos y de Optimizaci√≥n</h2>
<p> Este tipo de algoritmos se inspira en el proceso de evoluci√≥n natural, utilizando t√©cnicas como la selecci√≥n natural, mutaci√≥n y cruce para encontrar soluciones √≥ptimas.</p>
<h3> Tipos comunes:</h3>
<ol> - Algoritmo Gen√©tico: Utiliza t√©cnicas de evoluci√≥n como la selecci√≥n y la cruza para encontrar soluciones a problemas complejos. </ol>
<ol> - Algoritmo de Optimizaci√≥n por Enjambre de Part√≠culas (PSO): Simula el comportamiento de un enjambre de part√≠culas para optimizar una funci√≥n.</ol>
<h3> Ejemplo:</h3>
<p> Algoritmo gen√©tico para encontrar la mejor ruta en un problema de optimizaci√≥n.</p>
<img src="https://www.researchgate.net/publication/26595043/figure/fig2/AS:394285737365504@1471016453042/Figura-2-Algoritmo-evolutivo-tipico.png"  width="500" height="250"> 
</td>
</tr>
</table>
<a href="Menu.html"> Volver</a>


