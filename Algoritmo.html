<DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmo</title>
    <style>
        video {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
<body bgcolor="cyan">
 <h1> Algoritmo  </h1>
<p> Un algoritmo es una secuencia finita y ordenada de instrucciones o pasos que se siguen para resolver un problema o realizar una tarea específica. Estos pasos deben ser bien definidos y ejecutables para producir un resultado, sirviendo como la base de la programación y el desarrollo de software. </p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/LampFlowchart-es.svg/1200px-LampFlowchart-es.svg.png"  width="500" height="600"> 
<img src="https://concepto.de/wp-content/uploads/2018/04/algoritmo-min-e1523301106897.jpg"  width="550" height="400"> 
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqHwUGEftbslnEMbKfZ8s7CyTkNUq7Ij1qHw&s"  width="550" height="400"> 
<h2> Características clave de los algoritmos </h2>
<ol> - Finito: Los algoritmos deben tener un número limitado de pasos para completarse. </ol>
<ol> - Ordenado: Los pasos deben seguir un orden específico para garantizar la resolución del problema. </ol>
<ol> - Definido: Cada paso debe estar claramente definido y sin ambigüedades. </ol>
<ol> - Ejecutable: Los pasos deben poder ser llevados a cabo por un sistema o máquina. </ol> 
<ol> - Resultante: Los algoritmos deben producir un resultado específico al finalizar. </ol>
<h2> Ejemplos de algoritmos </h2>
<ol> - Receta de cocina: </ol>
<p> Una receta es un algoritmo que detalla los pasos para preparar una comida. </p>
<ol> - Instrucciones de montaje: </ol>
<p> Las instrucciones para armar un mueble son un algoritmo que guía el proceso de ensamblaje. </p>
<ol> - Algoritmos de ordenamiento: </ol>
<p> En informática, los algoritmos de ordenamiento (como el de burbuja o el de selección) organizan listas de elementos en un orden específico. </p>
<ol> - Algoritmos de búsqueda: </ol>
<p> Los motores de búsqueda utilizan algoritmos para encontrar información relevante a partir de una consulta. </p>
<ol> - Algoritmos de recomendación: </ol>
<p> Platarformas como Netflix o Spotify utilizan algoritmos para recomendar contenido a los usuarios. 
En matemáticas, lógica, ciencias de la computación y disciplinas relacionadas, un algoritmo es un conjunto de instrucciones o reglas definidas y no-ambiguas, ordenadas y finitas que permite, típicamente, solucionar un problema, realizar un cómputo, procesar datos y llevar a cabo otras tareas o actividades.​ También sirve para resolver un cubo de Rubik. Dado un estado inicial y una entrada, siguiendo los pasos sucesivos se llega a un estado final y se obtiene una solución. Los algoritmos son el objeto de estudio de la algoritmia.</p>
<h2> Etimología </h2>
<p> La palabra castellana algoritmo deriva del latín algorithmus, que se acuñaría en el siglo XV a partir del latín algorismus, con influencia del griego arithmos, que significa «número», o de la latinización del apellido del matemático persa Al-Juarismi.[2]​[6]​La RAE, por su parte, propone que deriva del latín algobarismus, que derivaría del árabe clásico ḥisābu lḡubār, que significa «cálculo mediante cifras arábigas».</p>
<img src="https://elingenieroenaccion.files.wordpress.com/2018/09/que-es-un-algoritmo-featured.png"  width="600" height="600">  
<h2> Medios de expresión de un algoritmo </h2>
<p> Los algoritmos pueden ser expresados de muchas maneras, incluyendo al lenguaje natural, pseudocódigo, diagramas de flujo y lenguajes de programación entre otros. Las descripciones en lenguaje natural tienden a ser ambiguas y extensas. El usar pseudocódigo y diagramas de flujo evita muchas ambigüedades del lenguaje natural. Dichas expresiones son formas más estructuradas para representar algoritmos; no obstante, se mantienen independientes de un lenguaje de programación específico.</p>
<p> La descripción de un algoritmo suele hacerse en tres niveles:</p>
<ol> - Descripción de alto nivel. Se establece el problema, se selecciona un modelo matemático y se explica el algoritmo de manera verbal, posiblemente con ilustraciones y omitiendo detalles. </ol>
<ol> - Descripción formal. Se usa un pseudocódigo para describir la secuencia de pasos que encuentran la solución. </ol>
<ol> - Implementación. Se muestra el algoritmo expresado en un lenguaje de programación específico o algún objeto capaz de llevar a cabo instrucciones. </ol>
<p>También es posible incluir un teorema que demuestre que el algoritmo es correcto, un análisis de complejidad o ambos.</p>
<img src="data:image/jpeg;base64,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 "  width="500" height="400">  
<h2> Diagrama de flujo </h2>
<p> Los diagramas de flujo son descripciones gráficas de algoritmos; usan símbolos conectados con flechas para indicar la secuencia de instrucciones y están regidos por ISO.</p>
<p> Los diagramas de flujo se emplean para representar algoritmos pequeños, ya que abarcan mucho espacio y su construcción es laboriosa. Por su facilidad de lectura se utilizan como introducción a los algoritmos, descripción de un lenguaje y descripción de procesos a personas ajenas a la computación.</p>
<h2> Pseudocódigo </h2>
<p> El pseudocódigo (falso lenguaje, el prefijo pseudo significa falso) es una descripción de alto nivel de un algoritmo que emplea una mezcla de lenguaje natural con algunas convenciones sintácticas propias de lenguajes de programación, como asignaciones, ciclos y condicionales, aunque no está regido por ningún estándar.</p>
<p> El pseudocódigo está pensado para facilitar a las personas el entendimiento de un algoritmo y, por lo tanto, puede omitir detalles irrelevantes que son necesarios en una implementación. Programadores diferentes suelen utilizar convenciones distintas, que pueden estar basadas en la sintaxis de lenguajes de programación concretos. Sin embargo, el pseudocódigo, en general, es comprensible sin necesidad de conocer o usar un entorno de programación específico, y es a la vez suficientemente estructurado para que su implementación se pueda hacer directamente a partir de él.</p>
<p> Así, el pseudocódigo cumple con las funciones antes mencionadas para representar algo abstracto, los protocolos son los lenguajes para la programación. Busque fuentes más precisas para tener mayor comprensión del tema.</p>
<h2> Sistemas formales </h2> 
<p> La teoría de autómatas y la teoría de funciones recursivas proveen modelos matemáticos que formalizan el concepto de algoritmo. Los modelos más comunes son la máquina de Turing, máquina de registro y funciones μ-recursivas. Estos modelos son tan precisos como un lenguaje máquina, careciendo de expresiones coloquiales o ambigüedad; sin embargo, se mantienen independientes de cualquier computadora y de cualquier implementación.</p> 
<h2> Implementación </h2>
<p> Muchos algoritmos se han ideado para implementarse en un programa. No obstante, los algoritmos pueden ser implementados en otros medios, como una red neuronal, un circuito eléctrico o un aparato mecánico y eléctrico. Algunos algoritmos incluso se diseñan especialmente para implementarse usando lápiz y papel. El algoritmo de multiplicación tradicional, el algoritmo de Euclides, la criba de Eratóstenes y muchas formas de resolver la raíz cuadrada son solo algunos ejemplos.</p>
<h2> Variables </h2>
<p> Son elementos que toman valores específicos de un tipo de datos concreto. La declaración de una variable puede realizarse comenzando con var. Principalmente, existen dos maneras de otorgar valores iniciales a variables:
Mediante una sentencia de asignación.</p>
<p> Mediante un procedimiento de entrada de datos (por ejemplo: 'read').</p>
<h3> Ejemplo: </h3>
<p> ...</p> 
<p> i:=1; </p>
<p> read(n); </p> 
<p> while i < n do begin </p>
<p> (* cuerpo del bucle *) </p>
<p> i := i + 1 </p>
<p> end; </p>
<p> ... </p>
<h2> Estructuras secuenciales </h2>
<p> La estructura secuencial es aquella en la que una acción sigue a otra en secuencia. Las operaciones se suceden de tal modo que la salida de una es la entrada de la siguiente y así sucesivamente hasta el fin del proceso. La asignación de esto consiste en el paso de valores o resultados a una zona de la memoria. Dicha zona será reconocida con el nombre de la variable que recibe el valor. La asignación se puede clasificar de la siguiente forma:</p>

<ol> Simples: Consiste en pasar un valor constante a una variable (a ← 15)</ol>
<ol> Contador: Consiste en usarla como un verificador del número de veces que se realiza un proceso (a ← a + 1) </ol>
<ol> Acumulador: Consiste en usarla como un sumador en un proceso (a ← a + b) </ol>
<p> De trabajo: Donde puede recibir el resultado de una operación matemática que involucre muchas variables (a ← c + b*1/2).
<p> Un ejemplo de estructura secuencial, como obtener el área de un triángulo:</p>
<p> Inicio </p>
<p> ... </p>
<p> float b, h, a; </p>
<p> printf("Diga la base"); </p>
<p> scanf("%f", &b);</p>
<p> printf("Diga la altura");</p>
<p> scanf("%f", &h);</p>
<p> a = (b*h)/2;</p>
<p> printf("El área del triángulo es %f", a)</p>
<p> ... </p>
<p> Fin </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y19JABXAtTA?si=Ew5vOgoexRIIL3mE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/AlgoritmoRaiz.png/220px-AlgoritmoRaiz.png"  width="600" height="600"> 
<h2> Historia de los algoritmos </h2>
<h3> 1. Los Primeros Algoritmos (Antigüedad) </h3>
<p> Aunque el término "algoritmo" como lo entendemos hoy no existía, las primeras civilizaciones ya utilizaban procedimientos sistemáticos para resolver problemas matemáticos.</p>
<h4> 3000 a.C. - Egipto y Babilonia</h4>
<p> Egipcios y babilonios utilizaban métodos de cálculo para resolver problemas prácticos, como medir tierras o resolver ecuaciones simples, aunque estos procedimientos no eran formalmente algoritmos en el sentido moderno. Sin embargo, ya empleaban reglas secuenciales para realizar operaciones.</p>
<h4> 300 a.C. - Euclides y el algoritmo de Euclides</h4>
<p> Uno de los primeros algoritmos registrados es el algoritmo de Euclides para encontrar el máximo común divisor (MCD) de dos números. Este algoritmo, descrito por Euclides en su obra Elementos, sigue siendo uno de los más importantes y se utiliza hasta el día de hoy.<p>

<h3> 2. Edad Media y el Renacimiento (Siglos V - XVI) </h3>
<p> Durante la Edad Media, los matemáticos islámicos y europeos continuaron desarrollando y transmitiendo técnicas que pueden considerarse algoritmos en el sentido más amplio.</p>
<h4> 800 d.C. - Al-Juarismi y la palabra "Algoritmo"</h4>
<p> El término "algoritmo" proviene de Al-Juarismi, un matemático y astrónomo persa. Su obra Al-Kitab al-Mukhtasar fi Hisab al-Jabr wal-Muqabala (El libro sobre cálculo por restauración y reducción) fue fundamental en la creación del álgebra. En este libro, describió procedimientos sistemáticos para resolver ecuaciones lineales y cuadráticas. Los procedimientos descritos por Al-Juarismi fueron una de las primeras formas de lo que más tarde sería conocido como un algoritmo.<p>
<h4> Siglo XIII - Fibonacci</h4>
<p> Leonardo de Pisa (conocido como Fibonacci) introdujo en Europa el sistema numérico indo-arábigo, que reemplazó al sistema romano y facilitó los cálculos. Su obra Liber Abaci también presentaba algoritmos para operaciones aritméticas usando los nuevos números.<p>

<h3> 3. El Siglo XVII y XVIII - El Nacimiento de la Ciencia de la Computación </h3>
<p> Con el advenimiento de la Era Moderna, los conceptos de matemática y algoritmos empezaron a formalizarse más claramente.</p>
<h4>1620 - John Napier y los logaritmos</h4>
<p> John Napier desarrolló los logaritmos, que simplificaron la multiplicación y división de números grandes. Aunque no era un "algoritmo" en el sentido de programación, el concepto de reducir un problema complejo a pasos más simples a través de tablas y reglas fue una contribución importante al desarrollo del pensamiento algorítmico.<p>
<h4> 1670 - Gottfried Wilhelm Leibniz y la máquina de calcular</h4>
<p>Leibniz ideó un mecanismo para la multiplicación utilizando la máquina de calcular. Este trabajo representó un avance importante hacia la creación de máquinas automáticas que ejecutaban secuencias de operaciones, precursoras de los algoritmos computacionales.</p>

<h3> 4. El Siglo XIX - El Desarrollo de la Computación Teórica </h3>
<h4> 1830 - Charles Babbage y la máquina analítica</h4>
Charles Babbage, considerado el padre de la computadora, diseñó la máquina analítica, que contenía los elementos fundamentales de las computadoras modernas: una unidad de procesamiento, memoria y entrada/salida. Su máquina podía ejecutar algoritmos de manera secuencial para resolver problemas matemáticos complejos. Aunque nunca se construyó una máquina funcional en su tiempo, sus ideas fueron fundamentales para el desarrollo de la computación.
<h4> 1840 - Ada Lovelace y el primer algoritmo </h4>
<p> Ada Lovelace, la hija de Lord Byron, fue la primera persona en entender que la máquina analítica de Babbage podía ir más allá de simples cálculos numéricos. En sus notas, Lovelace escribió el primer algoritmo pensado para ser ejecutado por una máquina, específicamente para calcular los números de Bernoulli. Esta contribución se considera el primer algoritmo informático y la base de la programación moderna.<p>

<h3> 5. El Siglo XX - Formalización y Avances en Computación </h3>
<h4> 1936 - Alan Turing y la máquina de Turing </h4>
<p> Alan Turing, en su trabajo sobre la máquina de Turing, formalizó la idea de un algoritmo como un conjunto de instrucciones que pueden ser ejecutadas paso a paso. La máquina de Turing se convirtió en un modelo matemático para la computación y permitió definir el concepto de computación y algoritmo en términos formales. La tesis de Church-Turing afirma que cualquier función que pueda ser computada por un algoritmo puede ser calculada por una máquina de Turing.</p>
<h4> 1940 - Desarrollo de las primeras computadoras electrónicas </h4>
<p> Con la creación de las primeras computadoras electrónicas, los algoritmos empezaron a ejecutarse en máquinas reales, dando lugar a la computación moderna. Las primeras computadoras programables, como la ENIAC y la Colossus, empezaron a utilizar algoritmos para realizar tareas matemáticas complejas.</p>
<h4> 1950 - El avance en la programación estructurada </h4>
<p> Los algoritmos comenzaron a ser implementados en lenguajes de programación como Fortran, COBOL y LISP. Estos lenguajes permitieron la formalización de algoritmos complejos y la creación de programas más eficientes.</p>

<h3> 6. Finales del Siglo XX y el Siglo XXI - Algoritmos en la Era Digital </h3>
<h4> 1990 - El auge de la informática y el desarrollo de internet</h4>
La aparición de internet y las redes sociales amplió enormemente el uso de algoritmos en áreas como la búsqueda de información (con el algoritmo de Google Search), la seguridad (con algoritmos de encriptación), y el análisis de datos (con big data y machine learning).
<h4> 2000 - Los algoritmos en la vida cotidiana</h4>
<p> En el siglo XXI, los algoritmos están presentes en prácticamente todos los aspectos de la vida diaria, desde recomendaciones de productos y servicios de streaming, hasta toma de decisiones financieras y vehículos autónomos. </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/EkObhToiseo?si=76jOM6TuOirNu7pe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdN0YK3nFrxxk8YH85Gi9ZuxIi4h4o8ZakqQ&s"  width="600" height="600"> 
<img src="https://www.lifeder.com/wp-content/uploads/2017/12/algoritmo-concepto-lifeder.jpg"  width="600" height="600"> 
<h2> Tipos de Algoritmos </h2>
<table border="1">
<tr> 
<td>
​​<h2> 1. Algoritmos de Búsqueda </h2>
<p> Los algoritmos de búsqueda se utilizan para encontrar un valor o una información dentro de una estructura de datos.</p>
<h3> Tipos comunes:</h3>
<ol> - Búsqueda Lineal: Examina cada elemento en una lista secuencialmente hasta encontrar el valor deseado.</ol>
<ol> - Búsqueda Binaria: Utilizada en listas ordenadas, divide el rango de búsqueda a la mitad en cada iteración hasta encontrar el elemento.</ol>
<h3> Ejemplo: </h3>
<p> Búsqueda Binaria en un arreglo ordenado de números.</p>
<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSZqq_Kr7fYByASOUCcAOIwU0kmnQzA6bQGow&s"  width="500" height="250"> 
</td>
<td>
<h2> 2. Algoritmos de Ordenación </h2>
<p> Los algoritmos de ordenación organizan un conjunto de datos en un orden específico (ascendente o descendente).</p>
<h3> Tipos comunes:</h3>
<ol> - Ordenación por Burbuja (Bubble Sort): Compara elementos adyacentes y los intercambia si están en el orden incorrecto.</ol>
<ol> - Ordenación Rápida (Quick Sort): Utiliza un pivote para dividir y conquistar, ordenando los elementos en sublistas.</ol> 
<ol> - Ordenación por Inserción (Insertion Sort): Inserta cada nuevo elemento en la posición correcta dentro de una lista ordenada. </ol>
<ol> - Merge Sort: Divide la lista en sublistas, las ordena y luego las fusiona.</ol>
<h3> Ejemplo: </h3>
<p> Ordenación por Burbuja para ordenar una lista de números.</p>
<img src="https://users.dcc.uchile.cl/~lmateu/CC10A/Apuntes/ordenamiento/seleccion.gif"  width="500" height="250"> 
</td>
<td>
<h2> 3. Algoritmos de Optimización</h2>
<p> Estos algoritmos se utilizan para encontrar la mejor solución o el valor más óptimo bajo ciertas condiciones o restricciones.</p>
<h3> Tipos comunes:</h3>
<ol> - Algoritmo de Dijkstra: Encuentra el camino más corto entre dos nodos en un grafo ponderado.</ol>
<ol> - Algoritmo A*: Utiliza heurísticas para encontrar el camino más corto entre puntos en un mapa o grafo.</ol>
<ol> - Algoritmo de Monte Carlo: Utiliza simulación estocástica para encontrar una solución aproximada a problemas complejos.</ol>
<h3> Ejemplo: </h3>
<p> Dijkstra para encontrar el camino más corto en un mapa de ciudades.</p>
<img src="https://cdn.agenciasinc.es/var/ezwebin_site/storage/images/noticias/un-algoritmo-probabilistico-para-optimizar-soluciones-complejas/8158941-2-esl-MX/Un-algoritmo-probabilistico-para-optimizar-soluciones-complejas.jpg"  width="500" height="250"> 
</td>
</tr>
<tr>
<td>
<h2> 4. Algoritmos de Divide y Vencerás</h2>
<p> Este tipo de algoritmo resuelve un problema dividiéndolo en subproblemas más pequeños, los resuelve de manera recursiva y luego combina las soluciones.</p>
<h3> Tipos comunes:</h3>
<ol> - Merge Sort: Divide el arreglo en sublistas, las ordena y luego las fusiona.</ol>
<ol> - Quick Sort: Divide el arreglo en dos partes con un pivote y ordena las partes recursivamente.</ol>
<h3> Ejemplo:</h3>
<p>  Merge Sort para ordenar una lista.</p>
<img src="https://cdn.kastatic.org/ka-perseus-images/db9d172fc33b90e905c1213b8cce660c228bb99c.png"  width="500" height="450"> 
</td>
<td>
<h2> 5. Algoritmos Voraces (Greedy)</h2>
<p> Son aquellos que, en cada paso, seleccionan la opción que parece ser la mejor en el momento, sin considerar las futuras consecuencias.</p>
<h3> Tipos comunes:</h3>
<ol> Algoritmo de Kruskal: Encuentra el árbol de expansión mínima en un grafo.</ol>
<ol> Algoritmo de Prim: También encuentra el árbol de expansión mínima en un grafo, pero con una estrategia diferente.</ol>
<h3> Ejemplo: </h3>
<p> Algoritmo de Kruskal para encontrar el árbol de expansión mínima.</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/d/da/Greedy_algorithm_36_cents.svg"  width="300" height="150"> 
</td>
<td>
<h2> 6. Algoritmos de Programación Dinámica</h2>
<p> Estos algoritmos resuelven problemas complejos dividiéndolos en subproblemas más pequeños y luego combinando sus soluciones. Son muy útiles cuando el mismo subproblema se repite muchas veces.</p>
<h3> Tipos comunes:</h3>
<p> Algoritmo de Fibonacci: Calcula el n-ésimo número de Fibonacci utilizando programación dinámica. </p>
<p> Algoritmo de la mochila (Knapsack Problem): Resuelve problemas de optimización donde se deben seleccionar elementos con un valor y peso determinado.</p>
<p> Problema de la subsecuencia común más larga: Encuentra la subsecuencia más larga que es común en dos secuencias dadas. </p>
<h3> Ejemplo:</h3>
<p> Problema de la mochila donde se busca la combinación más valiosa de elementos sin exceder el peso máximo. </p>
<img src="https://camo.githubusercontent.com/86c45fec5468cd06862e7b91b7d45722b6090259b3b44baebe2c66659d0827ad/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6d616b6569747265616c2f696d616765732f66756c6c2d737461636b2d637572726963756c756d2f64796e616d69632d70726f6772616d6d696e672d312e706e67"  width="400" height="250"> 
</td>
</tr>
<tr>
<td>
<h2> 7. Algoritmos de Recursión</h2>
<p> En estos algoritmos, la solución de un problema depende de la solución de subproblemas más pequeños del mismo tipo.</p>
<h3> Ejemplos comunes: </h3>
<ol> - Factorial de un número: El factorial de un número </ol>
<p> 𝑛 </p>
<p> n se define como </p>
<p> 𝑛! = 𝑛 × (𝑛 − 1) × ( 𝑛 − 2 ) × ⋯ × 1</p>
<p> n!=n×(n−1)×(n−2)×⋯×1.</p>
<ol> - Algoritmo de Fibonacci: La secuencia de Fibonacci puede calcularse recursivamente.</ol>
<h3> Ejemplo:</h3>
<p> Recursión para calcular el factorial de un número.</p>
<img src="https://www.netmentor.es/imagen/f1c3ac2d-c77c-48d3-b5c1-227704aa9ff7.jpg"  width="400" height="250"> 
</td>
<td>
<h2> 8. Algoritmos de Grafos</h2>
<p> Se utilizan para resolver problemas relacionados con redes de nodos y enlaces. Los grafos pueden ser dirigidos o no dirigidos, y los algoritmos resuelven problemas como la búsqueda de caminos, conectividad, y el flujo máximo.</p>
<h3> Tipos comunes:</h3>
<ol> - Búsqueda en Profundidad (DFS): Explora un grafo comenzando desde un nodo y profundizando lo más posible antes de retroceder.</ol>
<ol> - Búsqueda en Anchura (BFS): Explora un grafo comenzando desde un nodo y recorriendo todos los nodos vecinos antes de profundizar más.</ol>
<ol> - Algoritmo de Floyd-Warshall: Encuentra el camino más corto entre todos los pares de nodos en un grafo.</ol>
<h3> Ejemplo:</h3>
<p> DFS para recorrer un laberinto.</p>
<img src="https://users.dcc.uchile.cl/~bebustos/apuntes/cc3001/Grafos/grafo1.gif"  width="500" height="250"> 
</td>
<td>
<h2> 9. Algoritmos de Encriptación y Seguridad </h2>
<p> Estos algoritmos se utilizan para proteger la información a través de métodos de encriptación y seguridad de datos.</p>
<h3> Tipos comunes:</h3>
<ol> - Algoritmo de Cifrado RSA: Utilizado para encriptar y proteger la información en sistemas de comunicación.</ol>
<ol> - Algoritmo AES (Advanced Encryption Standard): Estándar de encriptación para proteger datos confidenciales.</ol>
<h3> Ejemplo: </h3>
<p> RSA para encriptar información confidencial.</p>
<img src="https://kinsta.com/wp-content/uploads/2023/07/what-is-encryption.jpg"  width="500" height="250"> 
</td>
</tr>
<tr>
<td>
<h2> 10. Algoritmos de Machine Learning (Aprendizaje Automático)</h2>
<p> Estos algoritmos permiten a las máquinas aprender patrones a partir de los datos y hacer predicciones o clasificaciones sin programación explícita.</p>
<h3> Tipos comunes:</h3>
<ol> - Regresión Lineal: Utilizado para predecir un valor continuo basado en características de entrada.</ol>
<ol> - Árboles de Decisión: Utilizados para clasificación y regresión, dividen el conjunto de datos en grupos según criterios específicos. </ol>
<ol> - Redes Neuronales Artificiales: Modelos que imitan el cerebro humano y son utilizados para tareas como clasificación de imágenes, procesamiento de lenguaje natural, etc.</ol>
<h3> Ejemplo: </h3>
<p> Árbol de decisión para clasificar correos electrónicos como spam o no spam.</p>
<img src="https://vissonar.com/wp-content/uploads/2018/11/machine-learning-ejemplos-sector-fintech.jpg"  width="500" height="350"> 
</td>
<td>
<h2> 11. Algoritmos Evolutivos y de Optimización</h2>
<p> Este tipo de algoritmos se inspira en el proceso de evolución natural, utilizando técnicas como la selección natural, mutación y cruce para encontrar soluciones óptimas.</p>
<h3> Tipos comunes:</h3>
<ol> - Algoritmo Genético: Utiliza técnicas de evolución como la selección y la cruza para encontrar soluciones a problemas complejos. </ol>
<ol> - Algoritmo de Optimización por Enjambre de Partículas (PSO): Simula el comportamiento de un enjambre de partículas para optimizar una función.</ol>
<h3> Ejemplo:</h3>
<p> Algoritmo genético para encontrar la mejor ruta en un problema de optimización.</p>
<img src="https://www.researchgate.net/publication/26595043/figure/fig2/AS:394285737365504@1471016453042/Figura-2-Algoritmo-evolutivo-tipico.png"  width="500" height="250"> 
</td>
</tr>
</table>
<a href="Menu.html"> Volver</a>


